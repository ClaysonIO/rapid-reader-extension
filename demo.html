<!DOCTYPE html>
<html>
<head>
  <title>Rapid Reader Demo</title>
  <meta charset="UTF-8">
  <style>
    body {
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      max-width: 800px;
      margin: 0 auto;
      padding: 20px;
      background-color: #f8f9fa;
    }
    
    h1, h2 {
      color: #3498db;
    }
    
    .container {
      display: flex;
      flex-direction: column;
      gap: 20px;
    }
    
    .demo-text {
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      padding: 20px;
      line-height: 1.6;
    }
    
    .rsvp-container {
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      padding: 20px;
    }
    
    .rsvp-display {
      height: 100px;
      display: flex;
      align-items: center;
      justify-content: center;
      border: 1px solid #e0e0e0;
      border-radius: 4px;
      background-color: #fafafa;
      margin-bottom: 20px;
      position: relative;
    }
    
    .rsvp-word {
      flex: 1;
      font-size: 32px;
      font-weight: 500;
      line-height: 1.2;
      white-space: nowrap;
      position: relative;
      display: flex;
    }
    
    .highlight {
      color: #e74c3c;
      font-weight: bold;
      position: relative;
    }
    
    /* Add a vertical line to mark the center */
    .rsvp-display::after {
      content: '';
      position: absolute;
      top: 0;
      bottom: 0;
      left: 50%;
      width: 1px;
      background-color: rgba(0, 0, 0, 0.1);
      z-index: 1;
    }
    
    /* Position the spans to keep the red letter centered */
    .before {
      text-align: right;
      flex: 1;
    }
    
    .after {
      text-align: left;
      flex: 1;
    }
    
    .controls {
      display: flex;
      flex-direction: column;
      gap: 15px;
    }
    
    .speed-control {
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .speed-control label {
      min-width: 85px;
    }
    
    .speed-control input[type="range"] {
      flex-grow: 1;
    }
    
    #wpm-value {
      font-weight: bold;
      min-width: 40px;
      text-align: right;
    }
    
    .buttons {
      display: flex;
      gap: 10px;
    }
    
    button {
      flex: 1;
      padding: 10px 15px;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-weight: 500;
      transition: background-color 0.2s;
    }
    
    #start-btn {
      background-color: #2ecc71;
      color: white;
    }
    
    #start-btn:hover {
      background-color: #27ae60;
    }
    
    #pause-btn {
      background-color: #3498db;
      color: white;
    }
    
    #pause-btn:hover {
      background-color: #2980b9;
    }
    
    #pause-btn:disabled {
      background-color: #95a5a6;
      cursor: not-allowed;
    }
    
    #reset-btn {
      background-color: #e74c3c;
      color: white;
    }
    
    #reset-btn:hover {
      background-color: #c0392b;
    }
    
    .progress {
      height: 8px;
      background-color: #ecf0f1;
      border-radius: 4px;
      margin: 15px 0;
      overflow: hidden;
      cursor: pointer; /* Add cursor pointer to indicate it's clickable */
    }
    
    .progress-bar {
      height: 100%;
      background-color: #3498db;
      width: 0%;
      transition: width 0.3s ease;
    }
    
    .info {
      background-color: #fff;
      border-radius: 8px;
      box-shadow: 0 2px 5px rgba(0, 0, 0, 0.1);
      padding: 20px;
    }
    
    .info p {
      margin: 10px 0;
    }
  </style>
</head>
<body>
  <div class="container">
    <h1>Rapid Reader Demo</h1>
    
    <div class="demo-text">
      <h2>Sample Text</h2>
      <p id="sample-text">
        The RSVP (Rapid Serial Visual Presentation) reading method is designed to help you read faster by eliminating the need for your eyes to move from word to word. Traditional reading involves a lot of eye movement, which takes time and energy. With RSVP, words are presented one at a time in a fixed position, with the Optimal Recognition Point (ORP) highlighted. This allows your brain to process words more efficiently, potentially increasing reading speed without sacrificing comprehension. The technique works by training your brain to recognize words quickly without the need for saccades, which are the rapid eye movements that occur during normal reading. By reducing these movements, RSVP helps readers achieve speeds of up to 1000 words per minute, compared to the average reading speed of 200-300 words per minute.
      </p>
    </div>
    
    <div class="rsvp-container">
      <h2>Rapid Reader</h2>
      <div class="rsvp-display">
        <div class="rsvp-word">
          <span class="before"></span><span class="highlight">â€¢</span><span class="after"></span>
        </div>
      </div>
      
      <div class="controls">
        <div class="speed-control">
          <label for="wpm">Speed (WPM):</label>
          <input type="range" id="wpm" min="100" max="800" step="25" value="300">
          <span id="wpm-value">300</span>
        </div>
        
        <div class="buttons">
          <button id="start-btn">Start</button>
          <button id="pause-btn" disabled>Pause</button>
          <button id="reset-btn">Reset</button>
        </div>
      </div>
      
      <div class="progress">
        <div class="progress-bar" id="progress-bar"></div>
      </div>
      
      <p id="word-count">Words: 0</p>
    </div>
    
    <div class="info">
      <h2>How RSVP Works</h2>
      <p>The RSVP technique works by:</p>
      <ol>
        <li>Presenting words one at a time in a fixed position</li>
        <li>Highlighting the Optimal Recognition Point (ORP) of each word (typically near 30% of the word length)</li>
        <li>This reduces the need for eye movement, allowing faster reading while maintaining comprehension</li>
      </ol>
      <p>Try adjusting the speed slider to find your comfortable reading speed. Most people can comfortably read at 300-400 WPM using this technique with a little practice.</p>
    </div>
    
    <div class="footer" style="text-align: center; margin-top: 20px; font-size: 14px; color: #7f8c8d;">
      <p><a href="privacy_policy.html" style="color: #3498db; text-decoration: none;">Privacy Policy</a> | <a href="https://github.com/ClaysonIO/rapid-reader-extension" style="color: #3498db; text-decoration: none;" target="_blank">Open Source</a></p>
    </div>
  </div>
  
  <script>
    // Global variables
    let words = [];
    let currentIndex = 0;
    let intervalId = null;
    let wpm = 300;
    let isPlaying = false;
    
    // DOM elements
    const startBtn = document.getElementById('start-btn');
    const pauseBtn = document.getElementById('pause-btn');
    const resetBtn = document.getElementById('reset-btn');
    const wpmSlider = document.getElementById('wpm');
    const wpmValue = document.getElementById('wpm-value');
    const wordCount = document.getElementById('word-count');
    const progressBar = document.getElementById('progress-bar');
    const progressContainer = document.querySelector('.progress');
    const beforeSpan = document.querySelector('.before');
    const highlightSpan = document.querySelector('.highlight');
    const afterSpan = document.querySelector('.after');
    const sampleText = document.getElementById('sample-text');
    
    // Variables for drag functionality
    let isDragging = false;
    
    // Initialize the demo
    document.addEventListener('DOMContentLoaded', () => {
      // Set up event listeners
      startBtn.addEventListener('click', startReading);
      pauseBtn.addEventListener('click', pauseReading);
      resetBtn.addEventListener('click', resetReading);
      wpmSlider.addEventListener('input', updateWpm);
      
      // Add progress bar interaction events
      progressContainer.addEventListener('click', handleProgressClick);
      progressContainer.addEventListener('mousedown', handleProgressDragStart);
      document.addEventListener('mousemove', handleProgressDrag);
      document.addEventListener('mouseup', handleProgressDragEnd);
      
      // Load saved WPM from localStorage
      const savedWpm = localStorage.getItem('savedWpm');
      if (savedWpm) {
        wpm = parseInt(savedWpm);
        wpmSlider.value = wpm;
        wpmValue.textContent = wpm;
      }
      
      // Process the sample text
      processText(sampleText.textContent);
    });
    
    // Process the text for RSVP reading
    function processText(text) {
      // Split text into words and filter out empty strings
      words = text.split(/\s+/).filter(word => word.length > 0);
      
      // Update word count and reading time estimate
      updateWordCountAndTime();
      
      if (words.length > 0) {
        // Display the first word
        displayWord(0);
      }
    }
    
    // Display a word using the RSVP technique
    function displayWord(index) {
      if (index >= words.length) {
        pauseReading();
        return;
      }
      
      const word = words[index];
      
      // Find the optimal recognition point (ORP)
      // For RSVP, this is typically near 30% of the word length
      const orpIndex = Math.min(Math.max(Math.floor(word.length * 0.3), 0), word.length - 1);
      
      // Split the word into parts
      const beforeORP = word.substring(0, orpIndex);
      const orpChar = word.charAt(orpIndex);
      const afterORP = word.substring(orpIndex + 1);
      
      // Update the display
      beforeSpan.textContent = beforeORP;
      highlightSpan.textContent = orpChar;
      afterSpan.textContent = afterORP;
      
      // Update progress bar
      const progress = ((index + 1) / words.length) * 100;
      progressBar.style.width = `${progress}%`;
    }
    
    // Start the speed reading
    function startReading() {
      if (isPlaying || words.length === 0) return;
      
      isPlaying = true;
      startBtn.disabled = true;
      pauseBtn.disabled = false;
      
      // Calculate interval based on WPM
      const interval = 60000 / wpm; // milliseconds per word
      
      // Start the interval
      intervalId = setInterval(() => {
        displayWord(currentIndex);
        currentIndex++;
        
        if (currentIndex >= words.length) {
          clearInterval(intervalId);
          isPlaying = false;
          startBtn.disabled = false;
          pauseBtn.disabled = true;
        }
      }, interval);
    }
    
    // Pause the speed reading
    function pauseReading() {
      if (!isPlaying) return;
      
      clearInterval(intervalId);
      isPlaying = false;
      startBtn.disabled = false;
      pauseBtn.disabled = true;
    }
    
    // Reset the speed reading
    function resetReading() {
      clearInterval(intervalId);
      isPlaying = false;
      currentIndex = 0;
      
      startBtn.disabled = false;
      pauseBtn.disabled = true;
      
      // Reset progress bar
      progressBar.style.width = '0%';
      
      // Display the first word
      if (words.length > 0) {
        displayWord(0);
      }
    }
    
    // Update the WPM value
    function updateWpm() {
      wpm = parseInt(wpmSlider.value);
      wpmValue.textContent = wpm;
      
      // Save the WPM to localStorage
      localStorage.setItem('savedWpm', wpm);
      
      // Update reading time estimate with new WPM
      updateWordCountAndTime();
      
      // If currently playing, restart with new speed
      if (isPlaying) {
        pauseReading();
        startReading();
      }
    }
    
    // Update word count and reading time estimate
    function updateWordCountAndTime() {
      // Calculate reading time in minutes
      const readingTimeMinutes = words.length / wpm;
      
      // Convert to minutes:seconds format
      const minutes = Math.floor(readingTimeMinutes);
      const seconds = Math.round((readingTimeMinutes - minutes) * 60);
      
      // Format as MM:SS
      const timeFormatted = `${minutes}:${seconds.toString().padStart(2, '0')}`;
      
      // Update display
      wordCount.textContent = `Words: ${words.length} (${timeFormatted})`;
    }
    
    // Handle click on progress bar
    function handleProgressClick(event) {
      if (isPlaying) {
        pauseReading();
      }
      
      const rect = progressContainer.getBoundingClientRect();
      const clickPosition = (event.clientX - rect.left) / rect.width;
      
      // Calculate the new index based on click position
      const newIndex = Math.floor(clickPosition * words.length);
      
      // Update current index and display
      currentIndex = Math.min(Math.max(newIndex, 0), words.length - 1);
      displayWord(currentIndex);
    }
    
    // Handle drag start on progress bar
    function handleProgressDragStart(event) {
      isDragging = true;
      
      // If reading is in progress, pause it
      if (isPlaying) {
        pauseReading();
      }
      
      // Process the initial drag position
      handleProgressDrag(event);
    }
    
    // Handle dragging on progress bar
    function handleProgressDrag(event) {
      if (!isDragging) return;
      
      const rect = progressContainer.getBoundingClientRect();
      
      // Calculate drag position, clamped between 0 and 1
      const dragPosition = Math.min(Math.max((event.clientX - rect.left) / rect.width, 0), 1);
      
      // Calculate the new index based on drag position
      const newIndex = Math.floor(dragPosition * words.length);
      
      // Update current index and display
      currentIndex = Math.min(Math.max(newIndex, 0), words.length - 1);
      displayWord(currentIndex);
      
      // Update progress bar visually
      const progress = ((currentIndex + 1) / words.length) * 100;
      progressBar.style.width = `${progress}%`;
    }
    
    // Handle drag end
    function handleProgressDragEnd() {
      isDragging = false;
    }
  </script>
</body>
</html>
